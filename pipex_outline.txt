Create the pipes
Fork the process
if child
	connect stdin to file
	connect stdout to file
	exec command
if parent
	wait for all the childs
	once child exited, close the pipes

Idea :
Deal with the pipes error, but let the program playout if fork error : no zombies

// Initialize variables
int pipes[n-1][2];  // Array of pipes
int pid;             // Process ID
int i;

// Create pipes
for i = 0 to n-2 do
	if pipe(pipes[i]) < 0 then
		perror("pipe");
		exit(EXIT_FAILURE);
	endif
endfor

// Execute commands
for i = 0 to n-1 do
	pid = fork();
	if pid < 0 then
		perror("fork");
		exit(EXIT_FAILURE);
	elseif pid == 0 then
		// Child process
		if i > 0 then
			// Redirect stdin from the previous pipe's reading end
			dup2(pipes[i-1][0], STDIN_FILENO);
			close(pipes[i-1][0]);
		endif

		if i < n-1 then
			// Redirect stdout to the next pipe's writing end
			dup2(pipes[i][1], STDOUT_FILENO);
			close(pipes[i][1]);
		endif

		// Execute command i (cmd1, cmd2, ..., cmdn)
		execvp(commands[i], arguments[i]);

		// execvp only returns on error
		perror("execvp");
		exit(EXIT_FAILURE);
	else
		// Parent process
		// Close unused ends of the pipes
		if i > 0 then
			close(pipes[i-1][0]);  // Close previous pipe's reading end
			close(pipes[i-1][1]);  // Close previous pipe's writing end
		endif
	endif
endfor

// Wait for all child processes to complete
while wait(NULL) > 0 do
	continue;
endwhile


pipex funct

if (setup_processes(procarr, args))
	return (-1)
if !lst
	return
execprocs
close_pipes
free path
wait
	print err_msg
return last_err

setup_proc

proc

proc = init_proc
if !proc
	return
proc->args = get_args
	if (!args || error_nb)
		return
proc->in = pipes[i-1][0]
proc->out = pipes[i][1]
